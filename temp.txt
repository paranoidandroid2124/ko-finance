"""Persistence utilities for admin-controlled operations settings."""

from __future__ import annotations

import json
import secrets
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping, Optional

from core.logging import get_logger
from services.admin_audit import append_audit_log, read_audit_logs
from services.admin_shared import (
    ADMIN_BASE_DIR,
    ensure_admin_dir,
    ensure_parent_dir,
    now_iso,
    parse_iso_datetime,
)
from datetime import datetime, timezone

logger = get_logger(__name__)

_ADMIN_DIR = ADMIN_BASE_DIR
_OPS_PIPELINE_PATH = _ADMIN_DIR / "ops_news_pipeline.json"
_OPS_API_KEYS_PATH = _ADMIN_DIR / "ops_api_keys.json"
_OPS_RUN_HISTORY_PATH = _ADMIN_DIR / "ops_run_history.jsonl"
_OPS_ALERT_CHANNELS_PATH = _ADMIN_DIR / "ops_alert_channels.json"

_DEFAULT_PIPELINE: Dict[str, object] = {
    "rssFeeds": [
        "https://www.yonhapnewstv.co.kr/browse/feed/",
        "https://www.hankyung.com/feed",
    ],
    "sectorMappings": {
        "금융": ["금리", "은행"],
        "반도체": ["메모리", "파운드리"],
    },
    "sentiment": {"threshold": 0.55},
    "updatedAt": None,
    "updatedBy": None,
}

_DEFAULT_API_KEYS: Dict[str, object] = {
    "langfuse": {
        "defaultEnvironment": "production",
        "environments": [
            {
                "name": "production",
                "enabled": True,
                "host": None,
                "publicKey": None,
                "maskedPublicKey": None,
                "secretKey": None,
                "maskedSecretKey": None,
                "expiresAt": None,
                "warningThresholdDays": 14,
                "lastRotatedAt": None,
                "rotationHistory": [],
                "note": None,
            }
        ],
    },
    "externalApis": [],
    "updatedAt": None,
    "updatedBy": None,
    "note": None,
}


_ALERT_TEMPLATE_GALLERY: List[Dict[str, object]] = [
    {
        "key": "slack-morning-brief",
        "label": "슬랙 · 아침 투자 브리핑",
        "channelType": "slack",
        "template": "markdown",
        "messageTemplate": "[{company}] 오늘 새로 확인한 따뜻한 소식을 전해드려요! {message}",
        "metadata": {
            "headline": "ESG 리포트가 새롭게 공개됐어요",
            "summary": "핵심 변화를 두 줄로 요약해두었어요. 자세한 근거는 하단 링크에서 살펴보실 수 있어요.",
            "url": "https://k-finance.example.com/evidence/esg-weekly",
            "volume": "12,345주",
            "markdown": "*{headline}*
{summary}
- 거래량: {volume}
- 바로가기: {url}",
            "subject": "[K-Finance] 오늘의 따뜻한 금융 브리핑",
        },
        "description": "슬랙 채널에 하루의 시작을 알리는 짧은 요약을 전달할 때 사용해요.",
    },
    {
        "key": "email-weekly-digest",
        "label": "이메일 · 주간 인사이트",
        "channelType": "email",
        "template": None,
        "messageTemplate": None,
        "metadata": {
            "subject_template": "[K-Finance] {company} 한 주 살펴보기",
            "body_template": "안녕하세요! {company} 관련 새로 수집한 근거를 따뜻하게 정리해두었어요.

- 주요 이슈: {headline}
- 추가 자료: {url}

함께 나누고 싶은 의견이 있으면 언제든 답장 주세요!",
            "company": "한빛에너지",
            "headline": "재무제표에 반영된 친환경 투자 확대",
            "url": "https://k-finance.example.com/reports/hanbit",
        },
        "description": "구독자에게 주간 변화를 차분한 어조로 공유하는 이메일 형식이에요.",
    },
    {
        "key": "telegram-alert",
        "label": "텔레그램 · 즉시 알림",
        "channelType": "telegram",
        "template": None,
        "messageTemplate": "[긴급] {company} 관련 새 소식이 들어왔어요! {message}",
        "metadata": {
            "company": "빛나은행",
            "message": "신용평가사가 등급 전망을 상향했어요. 세부 지표를 바로 확인해보세요!",
            "link": "https://k-finance.example.com/alerts/bnn",
        },
        "description": "중요 이벤트를 빠르게 전달하면서도 배려 있는 문장을 유지한 템플릿입니다.",
    },
]

_DEFAULT_ALERT_CHANNELS: Dict[str, object] = {
    "channels": [],
    "updatedAt": None,
    "updatedBy": None,
    "note": None,
}


def _normalize_text(value: Any) -> Optional[str]:
    if value is None:
        return None
    if isinstance(value, str):
        candidate = value.strip()
        return candidate or None
    return str(value)


def _sanitize_metadata_map(value: Any) -> Dict[str, Any]:
    metadata: Dict[str, Any] = {}
    if isinstance(value, Mapping):
        for key, entry in value.items():
            key_str = _normalize_text(key)
            if not key_str:
                continue
            metadata[key_str] = entry
    return metadata


def _normalize_integer(value: Any) -> Optional[int]:
    if value is None:
        return None
    if isinstance(value, bool):
        return int(value)
    if isinstance(value, int):
        return value
    if isinstance(value, float):
        return int(value)
    if isinstance(value, str):
        text = value.strip()
        if not text:
            return None
        try:
            return int(text)
        except ValueError:
            return None
    return None




def _normalize_langfuse_config(
    raw: Mapping[str, Any], existing_config: Optional[Mapping[str, Any]] = None
) -> Dict[str, Any]:
    if not isinstance(raw, Mapping):
        raw = {}
    default_env = _normalize_text(raw.get("defaultEnvironment")) or _normalize_text(raw.get("environment")) or "production"
    environments_raw = []
    if isinstance(raw.get("environments"), Iterable) and not isinstance(raw.get("environments"), (str, bytes)):
        environments_raw = [entry for entry in raw.get("environments") if isinstance(entry, Mapping)]
    elif raw:
        environments_raw = [raw]
    if not environments_raw:
        environments_raw = [
            {
                "name": default_env,
                "enabled": raw.get("enabled", True),
                "host": raw.get("host"),
                "publicKey": raw.get("publicKey"),
                "maskedPublicKey": raw.get("maskedPublicKey"),
                "secretKey": raw.get("secretKey"),
                "maskedSecretKey": raw.get("maskedSecretKey"),
                "expiresAt": raw.get("expiresAt"),
                "warningThresholdDays": raw.get("warningThresholdDays"),
                "lastRotatedAt": raw.get("lastRotatedAt"),
                "rotationHistory": raw.get("rotationHistory"),
                "note": raw.get("note"),
            }
        ]
    existing_map: Dict[str, Mapping[str, Any]] = {}
    if isinstance(existing_config, Mapping):
        for entry in existing_config.get("environments", []):
            if isinstance(entry, Mapping):
                name = _normalize_text(entry.get("name"))
                if name:
                    existing_map[name] = entry
    sanitized_envs: List[Dict[str, Any]] = []
    seen: set[str] = set()
    for entry in environments_raw:
        name = _normalize_text(entry.get("name")) or default_env
        if not name:
            name = "production"
        if name in seen:
            continue
        seen.add(name)
        sanitized_envs.append(_sanitize_langfuse_environment(entry, existing_map.get(name)))
    if not sanitized_envs:
        sanitized_envs.append(
            _sanitize_langfuse_environment({"name": default_env}, existing_map.get(default_env))
        )
    return {
        "defaultEnvironment": default_env,
        "environments": sanitized_envs,
    }


def _sanitize_langfuse_environment(
    entry: Mapping[str, Any], existing: Optional[Mapping[str, Any]] = None
) -> Dict[str, Any]:
    name = _normalize_text(entry.get("name")) or (
        _normalize_text(existing.get("name")) if isinstance(existing, Mapping) else "production"
    )
    enabled = bool(entry.get("enabled", existing.get("enabled") if isinstance(existing, Mapping) else True))
    host = _normalize_text(entry.get("host")) or (
        _normalize_text(existing.get("host")) if isinstance(existing, Mapping) else None
    )
    public_key = _normalize_text(entry.get("publicKey")) or (
        _normalize_text(existing.get("publicKey")) if isinstance(existing, Mapping) else None
    )
    masked_public = _normalize_text(entry.get("maskedPublicKey")) or (
        _normalize_text(existing.get("maskedPublicKey")) if isinstance(existing, Mapping) else None
    )
    secret_key = _normalize_text(entry.get("secretKey")) or (
        _normalize_text(existing.get("secretKey")) if isinstance(existing, Mapping) else None
    )
    masked_secret = _normalize_text(entry.get("maskedSecretKey")) or (
        _normalize_text(existing.get("maskedSecretKey")) if isinstance(existing, Mapping) else None
    )
    expires_at = _normalize_text(entry.get("expiresAt")) or (
        _normalize_text(existing.get("expiresAt")) if isinstance(existing, Mapping) else None
    )
    warning_days = (
        _normalize_integer(entry.get("warningThresholdDays"))
        if entry.get("warningThresholdDays") is not None
        else (
            _normalize_integer(existing.get("warningThresholdDays"))
            if isinstance(existing, Mapping)
            else None
        )
    )
    last_rotated = _normalize_text(entry.get("lastRotatedAt")) or (
        _normalize_text(existing.get("lastRotatedAt")) if isinstance(existing, Mapping) else None
    )
    history = _history_entries(entry.get("rotationHistory"))
    if not history and isinstance(existing, Mapping):
        history = _history_entries(existing.get("rotationHistory"))

    return {
        "name": name,
        "enabled": enabled,
        "host": host,
        "publicKey": public_key,
        "maskedPublicKey": masked_public,
        "secretKey": secret_key,
        "maskedSecretKey": masked_secret,
        "expiresAt": expires_at,
        "warningThresholdDays": warning_days,
        "lastRotatedAt": last_rotated,
        "rotationHistory": _sanitize_rotation_history(history),
        "note": _normalize_text(entry.get("note")) or (
            _normalize_text(existing.get("note")) if isinstance(existing, Mapping) else None
        ),
    }

def _history_entries(value: Any) -> List[Mapping[str, Any]]:
    if isinstance(value, Mapping):
        return [value]
    if isinstance(value, Iterable) and not isinstance(value, (str, bytes)):
        return [entry for entry in value if isinstance(entry, Mapping)]
    return []




def _compute_token_alerts(
    langfuse_config: Mapping[str, Any], external_apis: Iterable[Mapping[str, Any]]
) -> List[Dict[str, Any]]:
    alerts: List[Dict[str, Any]] = []
    now = datetime.now(timezone.utc)
    for env in langfuse_config.get("environments", []):
        if not isinstance(env, Mapping):
            continue
        name = _normalize_text(env.get("name")) or "production"
        expires_at = parse_iso_datetime(env.get("expiresAt"))
        warning_days = _normalize_integer(env.get("warningThresholdDays")) or 0
        if expires_at:
            delta = expires_at - now
            if delta.total_seconds() <= 0:
                alerts.append(
                    {
                        "source": f"langfuse:{name}",
                        "severity": "critical",
                        "message": "Langfuse 토큰이 만료되어 새 키가 필요해요.",
                        "detail": f"{name} 환경 키를 즉시 재발급해 주세요.",
                    }
                )
            elif warning_days and delta.days <= warning_days:
                alerts.append(
                    {
                        "source": f"langfuse:{name}",
                        "severity": "warning",
                        "message": "Langfuse 토큰 만료가 가까워졌어요.",
                        "detail": f"{name} 환경 키가 {delta.days}일 후 만료 예정이에요.",
                    }
                )
    for api in external_apis:
        if not isinstance(api, Mapping):
            continue
        name = _normalize_text(api.get("name")) or "external"
        expires_at = parse_iso_datetime(api.get("expiresAt"))
        warning_days = _normalize_integer(api.get("warningThresholdDays")) or 0
        if expires_at:
            delta = expires_at - now
            if delta.total_seconds() <= 0:
                alerts.append(
                    {
                        "source": f"external:{name}",
                        "severity": "critical",
                        "message": "외부 API 키가 만료되었어요.",
                        "detail": f"{name} 키를 새로 발급받아 연결을 복구해 주세요.",
                    }
                )
            elif warning_days and delta.days <= warning_days:
                alerts.append(
                    {
                        "source": f"external:{name}",
                        "severity": "warning",
                        "message": "외부 API 키 만료 알림",
                        "detail": f"{name} 키가 {delta.days}일 후 만료될 예정이에요.",
                    }
                )
    return alerts
def load_news_pipeline() -> Dict[str, object]:
    if _OPS_PIPELINE_PATH.exists():
        try:
            payload = json.loads(_OPS_PIPELINE_PATH.read_text(encoding="utf-8"))
            if isinstance(payload, dict):
                return payload
        except json.JSONDecodeError as exc:  # pragma: no cover
            logger.warning("Failed to parse news pipeline store: %s", exc)
    return dict(_DEFAULT_PIPELINE)


def save_news_pipeline(pipeline: Dict[str, object]) -> None:
    ensure_parent_dir(_OPS_PIPELINE_PATH, logger)
    try:
        _OPS_PIPELINE_PATH.write_text(json.dumps(pipeline, ensure_ascii=False, indent=2), encoding="utf-8")
    except OSError as exc:
        raise RuntimeError(f"Failed to write news pipeline config: {exc}") from exc


def update_news_pipeline(
    *,
    rss_feeds: Iterable[str],
    sector_mappings: Dict[str, Iterable[str]],
    sentiment: Dict[str, object],
    actor: str,
    note: Optional[str],
) -> Dict[str, object]:
    payload = {
        "rssFeeds": list(rss_feeds),
        "sectorMappings": {key: list(values) for key, values in sector_mappings.items()},
        "sentiment": dict(sentiment),
        "updatedAt": now_iso(),
        "updatedBy": actor,
        "note": note,
    }
    save_news_pipeline(payload)
    append_audit_log(
        filename="ops_audit.jsonl",
        actor=actor,
        action="news_pipeline_update",
        payload={"note": note, "feed_count": len(payload["rssFeeds"])},
    )
    return payload


def load_api_keys() -> Dict[str, object]:
    if _OPS_API_KEYS_PATH.exists():
        try:
            payload = json.loads(_OPS_API_KEYS_PATH.read_text(encoding="utf-8"))
            if isinstance(payload, dict):
                langfuse_config = _normalize_langfuse_config(payload.get("langfuse", {}))
                external_raw = payload.get("externalApis") if isinstance(payload.get("externalApis"), list) else []
                external_entries: List[Dict[str, Any]] = []
                for entry in external_raw:
                    if isinstance(entry, Mapping):
                        name = _normalize_text(entry.get("name")) or "external"
                        metadata = _sanitize_metadata_map(entry.get("metadata"))
                        sanitized = {
                            "name": name,
                            "maskedKey": _normalize_text(entry.get("maskedKey")),
                            "enabled": bool(entry.get("enabled", True)),
                            "metadata": metadata,
                            "expiresAt": _normalize_text(entry.get("expiresAt")),
                            "warningThresholdDays": _normalize_integer(entry.get("warningThresholdDays")),
                            "lastRotatedAt": _normalize_text(entry.get("lastRotatedAt")),
                            "rotationHistory": _sanitize_rotation_history(_history_entries(entry.get("rotationHistory"))),
                        }
                        external_entries.append(sanitized)
                result = {
                    "langfuse": langfuse_config,
                    "externalApis": external_entries,
                    "updatedAt": payload.get("updatedAt"),
                    "updatedBy": payload.get("updatedBy"),
                    "note": payload.get("note"),
                }
                result["alerts"] = _compute_token_alerts(langfuse_config, external_entries)
                return result
        except json.JSONDecodeError as exc:  # pragma: no cover
            logger.warning("Failed to parse ops api keys store: %s", exc)
    default_payload = json.loads(json.dumps(_DEFAULT_API_KEYS))
    default_payload["alerts"] = _compute_token_alerts(default_payload["langfuse"], default_payload.get("externalApis", []))
    return default_payload


def save_api_keys(secrets: Dict[str, object]) -> None:
    ensure_parent_dir(_OPS_API_KEYS_PATH, logger)
    payload = dict(secrets)
    payload.pop("alerts", None)
    try:
        _OPS_API_KEYS_PATH.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
    except OSError as exc:
        raise RuntimeError(f"Failed to write ops api keys: {exc}") from exc


def _mask_secret(value: str) -> str:
    if not isinstance(value, str):
        return ""
    trimmed = value.strip()
    if len(trimmed) <= 6:
        return "*" * len(trimmed)
    return f"{trimmed[:3]}{'*' * (len(trimmed) - 6)}{trimmed[-3:]}"


def update_api_keys(
    *,
    langfuse: Dict[str, object],
    external_apis: Iterable[Dict[str, object]],
    actor: str,
    note: Optional[str],
) -> Dict[str, object]:
    existing = load_api_keys()
    existing_langfuse = existing.get("langfuse") if isinstance(existing, Mapping) else {}
    normalized_config = _normalize_langfuse_config(langfuse, existing_langfuse)

    existing_env_map: Dict[str, Mapping[str, Any]] = {}
    if isinstance(existing_langfuse, Mapping):
        for env in existing_langfuse.get("environments", []):
            if isinstance(env, Mapping):
                name = _normalize_text(env.get("name"))
                if name:
                    existing_env_map[name] = env

    sanitized_envs: List[Dict[str, Any]] = []
    for env in normalized_config.get("environments", []):
        env_name = _normalize_text(env.get("name")) or "production"
        sanitized_envs.append(_sanitize_langfuse_environment(env, existing_env_map.get(env_name)))

    langfuse_payload = {
        "defaultEnvironment": _normalize_text(normalized_config.get("defaultEnvironment"))
        or (existing_langfuse.get("defaultEnvironment") if isinstance(existing_langfuse, Mapping) else "production"),
        "environments": sanitized_envs,
    }

    existing_external_map: Dict[str, Mapping[str, Any]] = {}
    if isinstance(existing.get("externalApis"), list):
        for entry in existing.get("externalApis"):
            if isinstance(entry, Mapping):
                key = _normalize_text(entry.get("name")) or ""
                if key:
                    existing_external_map[key] = entry

    sanitized_external: List[Dict[str, Any]] = []
    for index, entry in enumerate(external_apis):
        if not isinstance(entry, Mapping):
            continue
        name = _normalize_text(entry.get("name")) or f"external-{index + 1:02d}"
        existing_entry = existing_external_map.get(name)
        metadata = _sanitize_metadata_map(entry.get("metadata") or (existing_entry.get("metadata") if isinstance(existing_entry, Mapping) else {}))
        expires_at = _normalize_text(entry.get("expiresAt")) or (
            _normalize_text(existing_entry.get("expiresAt")) if isinstance(existing_entry, Mapping) else None
        )
        warning_days = (
            _normalize_integer(entry.get("warningThresholdDays"))
            if entry.get("warningThresholdDays") is not None
            else (
                _normalize_integer(existing_entry.get("warningThresholdDays"))
                if isinstance(existing_entry, Mapping)
                else None
            )
        )
        last_rotated = _normalize_text(entry.get("lastRotatedAt")) or (
            _normalize_text(existing_entry.get("lastRotatedAt")) if isinstance(existing_entry, Mapping) else None
        )
        history_candidates = _history_entries(entry.get("rotationHistory"))
        if not history_candidates and isinstance(existing_entry, Mapping):
            history_candidates = _history_entries(existing_entry.get("rotationHistory"))

        sanitized_external.append(
            {
                "name": name,
                "maskedKey": _normalize_text(entry.get("maskedKey")) or (
                    _normalize_text(existing_entry.get("maskedKey")) if isinstance(existing_entry, Mapping) else None
                ),
                "enabled": bool(entry.get("enabled", existing_entry.get("enabled") if isinstance(existing_entry, Mapping) else True)),
                "metadata": metadata,
                "expiresAt": expires_at,
                "warningThresholdDays": warning_days,
                "lastRotatedAt": last_rotated,
                "rotationHistory": _sanitize_rotation_history(history_candidates),
            }
        )

    payload = {
        "langfuse": langfuse_payload,
        "externalApis": sanitized_external,
        "updatedAt": now_iso(),
        "updatedBy": actor,
        "note": note,
    }
    payload["alerts"] = _compute_token_alerts(langfuse_payload, sanitized_external)
    save_api_keys(payload)
    append_audit_log(
        filename="ops_audit.jsonl",
        actor=actor,
        action="api_keys_update",
        payload={"note": note, "external_count": len(payload["externalApis"])},
    )
    return payload


def update_channel_status(
    key: str,
    *,
    enabled: bool,
    actor: str,
    note: Optional[str],
) -> Dict[str, object]:
    record = load_alert_channels()
    raw_channels = record.get("channels") if isinstance(record, Mapping) else None
    if not isinstance(raw_channels, list):
        raise ValueError("channel_store_empty")

    updated_channels: List[Dict[str, Any]] = []
    found = False
    now = now_iso()
    for entry in raw_channels:
        if not isinstance(entry, dict):
            continue
        channel = dict(entry)
        if str(channel.get("key") or "").strip() == key:
            previous_enabled = bool(channel.get("enabled", True))
            channel["enabled"] = bool(enabled)
            channel["updatedAt"] = now
            if previous_enabled and not enabled:
                channel["disabledAt"] = now
                channel["disabledBy"] = actor
                channel["disabledNote"] = note
            elif enabled:
                channel["disabledAt"] = None
                channel["disabledBy"] = None
                channel["disabledNote"] = None
            else:
                channel["disabledAt"] = channel.get("disabledAt") or now
                if not channel.get("disabledBy"):
                    channel["disabledBy"] = actor
                if channel.get("disabledNote") is None:
                    channel["disabledNote"] = note
            found = True
        updated_channels.append(channel)

    if not found:
        raise ValueError("channel_not_found")

    payload = {
        "channels": updated_channels,
        "updatedAt": now,
        "updatedBy": actor,
        "note": note,
    }
    save_alert_channels(payload)
    append_audit_log(
        filename="alerts_audit.jsonl",
        actor=actor,
        action="alert_channel_status",
        payload={"note": note, "channel_key": key, "enabled": bool(enabled)},
    )
    return payload


def build_channel_preview_payload(
    *,
    channel: Mapping[str, Any],
    sample_message: str,
    sample_metadata: Mapping[str, Any],
    actor: str,
) -> Dict[str, object]:
    from services.notification_service import build_channel_preview  # local import to avoid circular

    sanitized = _sanitize_alert_channel(channel, 0, existing=None)
    base_metadata = sanitized.get("metadata")
    combined_metadata: Dict[str, Any] = {}
    if isinstance(base_metadata, Mapping):
        combined_metadata.update(base_metadata)
    if isinstance(sample_metadata, Mapping):
        combined_metadata.update(sample_metadata)  # sample metadata 우선 적용

    preview = build_channel_preview(
        channel_type=sanitized.get("channelType"),
        message=str(sample_message),
        metadata=combined_metadata,
        template=sanitized.get("template"),
        message_template=sanitized.get("messageTemplate"),
    )

    return {
        "rendered": preview.get("payload") or {},
        "message": preview.get("message") or str(sample_message),
        "generatedAt": now_iso(),
        "templateUsed": preview.get("templateUsed"),
        "actor": actor,
    }


def rotate_langfuse_keys(
    *,
    actor: str,
    note: Optional[str],
) -> Dict[str, object]:
    existing = load_api_keys()
    langfuse_config = existing.get("langfuse") if isinstance(existing, Mapping) else _DEFAULT_API_KEYS["langfuse"]
    default_env = _normalize_text(langfuse_config.get("defaultEnvironment")) or "production"

    environments: List[Dict[str, Any]] = []
    target_found = False
    for env in langfuse_config.get("environments", []):
        if not isinstance(env, Mapping):
            continue
        env_name = _normalize_text(env.get("name")) or "production"
        if env_name == default_env and not target_found:
            new_public = f"lf_pub_{secrets.token_urlsafe(18)}"
            new_secret = f"lf_sec_{secrets.token_urlsafe(32)}"
            now = now_iso()
            updated_env = dict(env)
            updated_env.update(
                {
                    "publicKey": new_public,
                    "secretKey": new_secret,
                    "maskedPublicKey": _mask_secret(new_public),
                    "maskedSecretKey": _mask_secret(new_secret),
                    "lastRotatedAt": now,
                }
            )
            history = _history_entries(updated_env.get("rotationHistory"))
            history.insert(
                0,
                {
                    "rotatedAt": now,
                    "actor": actor,
                    "note": note,
                    "maskedKey": updated_env.get("maskedSecretKey"),
                },
            )
            updated_env["rotationHistory"] = _sanitize_rotation_history(history)
            environments.append(updated_env)
            target_found = True
        else:
            environments.append(dict(env))

    if not target_found:
        new_public = f"lf_pub_{secrets.token_urlsafe(18)}"
        new_secret = f"lf_sec_{secrets.token_urlsafe(32)}"
        now = now_iso()
        environments.append(
            {
                "name": default_env,
                "enabled": True,
                "host": None,
                "publicKey": new_public,
                "secretKey": new_secret,
                "maskedPublicKey": _mask_secret(new_public),
                "maskedSecretKey": _mask_secret(new_secret),
                "expiresAt": None,
                "warningThresholdDays": 14,
                "lastRotatedAt": now,
                "rotationHistory": [
                    {
                        "rotatedAt": now,
                        "actor": actor,
                        "note": note,
                        "maskedKey": _mask_secret(new_secret),
                    }
                ],
                "note": None,
            }
        )

    langfuse_payload = {
        "defaultEnvironment": default_env,
        "environments": environments,
    }

    external_entries = existing.get("externalApis") if isinstance(existing, Mapping) else []
    payload = {
        "langfuse": langfuse_payload,
        "externalApis": external_entries,
        "updatedAt": now_iso(),
        "updatedBy": actor,
        "note": note,
    }
    payload["alerts"] = _compute_token_alerts(langfuse_payload, external_entries)
    save_api_keys(payload)
    append_audit_log(
        filename="ops_audit.jsonl",
        actor=actor,
        action="langfuse_rotate",
        payload={"note": note, "environment": default_env},
    )
    return payload


def append_run_history(
    *,
    task_id: str,
    job_id: str,
    task: str,
    status: str,
    actor: str,
    note: Optional[str],
    started_at: Optional[str] = None,
    finished_at: Optional[str] = None,
) -> None:
    ensure_parent_dir(_OPS_RUN_HISTORY_PATH, logger)
    record = {
        "id": task_id,
        "jobId": job_id,
        "task": task,
        "status": status,
        "actor": actor,
        "note": note,
        "startedAt": started_at or now_iso(),
        "finishedAt": finished_at,
    }
    try:
        with _OPS_RUN_HISTORY_PATH.open("a", encoding="utf-8") as handle:
            handle.write(json.dumps(record, ensure_ascii=False))
            handle.write("\n")
    except OSError as exc:  # pragma: no cover
        logger.error("Failed to append ops run history: %s", exc)


def list_run_history(limit: int = 100) -> List[Dict[str, object]]:
    if not _OPS_RUN_HISTORY_PATH.exists():
        return []
    try:
        lines = _OPS_RUN_HISTORY_PATH.read_text(encoding="utf-8").splitlines()
    except OSError as exc:  # pragma: no cover
        logger.error("Failed to read ops run history: %s", exc)
        return []

    entries: List[Dict[str, object]] = []
    for line in reversed(lines[-limit:]):
        try:
            parsed = json.loads(line)
            if isinstance(parsed, dict):
                entries.append(parsed)
        except json.JSONDecodeError:
            continue
    return entries


def list_alert_templates() -> List[Dict[str, object]]:
    return [dict(item) for item in _ALERT_TEMPLATE_GALLERY]


def build_sample_metadata(
    *, channel_type: str, template: Optional[str] = None
) -> Dict[str, Any]:
    channel_key = (channel_type or "generic").lower()
    selected: Optional[Dict[str, Any]] = None
    if template:
        for entry in _ALERT_TEMPLATE_GALLERY:
            if entry.get("key") == template:
                selected = entry
                break
    metadata = dict(selected.get("metadata") if selected else {})
    now_iso = now_iso()
    if channel_key == "slack":
        metadata.setdefault("headline", "ESG 리포트가 새롭게 공개됐어요")
        metadata.setdefault(
            "summary",
            "핵심 변화를 두 줄로 정리해두었어요. 자세한 근거는 하단 링크에서 살펴보실 수 있어요.",
        )
        metadata.setdefault("url", "https://k-finance.example.com/evidence/esg-weekly")
        metadata.setdefault("volume", "12,345주")
        metadata.setdefault("markdown", "*{headline}*
{summary}
- 거래량: {volume}
- 바로가기: {url}")
        metadata.setdefault("subject", "[K-Finance] 오늘의 따뜻한 금융 브리핑")
    elif channel_key == "email":
        metadata.setdefault("company", "한빛에너지")
        metadata.setdefault("headline", "재무제표에 반영된 친환경 투자 확대")
        metadata.setdefault("url", "https://k-finance.example.com/reports/hanbit")
        metadata.setdefault(
            "subject_template",
            "[K-Finance] {company} 한 주 살펴보기",
        )
        metadata.setdefault(
            "body_template",
            "안녕하세요! {company} 관련 새로 수집한 근거를 따뜻하게 정리해두었어요.\n\n- 주요 이슈: {headline}\n- 추가 자료: {url}\n\n함께 나누고 싶은 의견이 있으면 언제든 답장 주세요!",
        )
    elif channel_key == "telegram":
        metadata.setdefault("company", "빛나은행")
        metadata.setdefault(
            "message",
            "신용평가사가 등급 전망을 상향했어요. 세부 지표를 바로 확인해보세요!",
        )
        metadata.setdefault("link", "https://k-finance.example.com/alerts/bnn")
    else:
        metadata.setdefault("message", "오늘도 투자 여정이 순항 중이에요. 궁금한 점이 생기면 바로 도와드릴게요!")
    metadata.setdefault("generatedAt", now_iso)
    metadata.setdefault("channel_type", channel_key)
    if selected and selected.get("messageTemplate"):
        metadata.setdefault("message", selected["messageTemplate"].format(company="K-Finance", message="새 알림이 도착했어요."))
    return metadata


def list_audit_records(
    *,
    limit: int = 200,
    sources: Optional[Iterable[str]] = None,
    actor: Optional[str] = None,
    action: Optional[str] = None,
    search: Optional[str] = None,
    since: Optional[str] = None,
    until: Optional[str] = None,
) -> List[Dict[str, Any]]:
    return read_audit_logs(
        limit=limit,
        sources=sources,
        actor=actor,
        action=action,
        search=search,
        since=since,
        until=until,
    )


__all__ = [
    "append_run_history",
    "list_run_history",
    "load_alert_channels",
    "load_api_keys",
    "load_news_pipeline",
    "save_alert_channels",
    "save_api_keys",
    "save_news_pipeline",
    "list_audit_records",
    "list_alert_templates",
    "build_sample_metadata",
    "build_channel_preview_payload",
    "create_alert_channel",
    "update_alert_channels",
    "update_api_keys",
    "update_channel_status",
    "update_news_pipeline",
    "rotate_langfuse_keys",
]
