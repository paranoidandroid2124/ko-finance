"""Tool-specific endpoints used by the dashboard overlay."""

from __future__ import annotations

import uuid
from typing import Optional

from fastapi import APIRouter, Depends, Header, HTTPException, status
from sqlalchemy.orm import Session

from database import get_db
from models.chat import ChatSession
from schemas.api.tools import ToolMemoryWriteRequest, ToolMemoryWriteResponse
from services import lightmem_gate, rag_audit
from services.plan_service import PlanContext
from services.web_utils import parse_uuid
from web.deps import require_plan_feature

router = APIRouter(prefix="/tools", tags=["Tools"])


def _compute_memory_subject_ids(
    session: ChatSession,
    user_id: Optional[uuid.UUID],
    org_id: Optional[uuid.UUID],
) -> Tuple[Optional[str], Optional[str]]:
    tenant_candidate = org_id or session.org_id or session.user_id or user_id
    user_candidate = session.user_id or user_id or org_id or tenant_candidate
    tenant_value = str(tenant_candidate) if tenant_candidate else None
    user_value = str(user_candidate) if user_candidate else None
    if tenant_value and not user_value:
        user_value = tenant_value
    if user_value and not tenant_value:
        tenant_value = user_value
    return tenant_value, user_value


@router.post(
    "/memory",
    response_model=ToolMemoryWriteResponse,
    status_code=status.HTTP_202_ACCEPTED,
    summary="Persist LightMem context generated by Commander tools.",
)
def record_tool_memory(
    payload: ToolMemoryWriteRequest,
    x_user_id: Optional[str] = Header(default=None, alias="X-User-Id"),
    x_org_id: Optional[str] = Header(default=None, alias="X-Org-Id"),
    plan: PlanContext = Depends(require_plan_feature("rag.core")),
    db: Session = Depends(get_db),
) -> ToolMemoryWriteResponse:
    session: Optional[ChatSession] = (
        db.query(ChatSession)
        .filter(ChatSession.id == payload.sessionId)
        .first()
    )
    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="chat_session_not_found")

    user_uuid = parse_uuid(x_user_id)
    org_uuid = parse_uuid(x_org_id)
    user_settings = lightmem_gate.load_user_settings(user_uuid)
    plan_memory_enabled = lightmem_gate.chat_enabled(plan, user_settings)
    if not plan_memory_enabled:
        return ToolMemoryWriteResponse(stored=False, reason="memory_disabled")

    tenant_value, user_value = _compute_memory_subject_ids(session, user_uuid, org_uuid)
    if not tenant_value or not user_value:
        return ToolMemoryWriteResponse(stored=False, reason="missing_subject")

    question = payload.question or payload.topic
    answer_candidates = [payload.answer] if payload.answer else []
    answer_candidates.extend(payload.highlights)
    answer = " / ".join(part for part in answer_candidates if isinstance(part, str) and part.strip())
    if not answer:
        answer = payload.topic

    stored = rag_audit.store_lightmem_summary(
        question=question,
        answer=answer,
        session=session,
        turn_id=payload.turnId,
        session_key=f"chat:{session.id}",
        tenant_id=tenant_value,
        user_id=user_value,
        plan_memory_enabled=plan_memory_enabled,
        rag_mode=payload.metadata.get("ragMode") or f"tool.{payload.toolId}",
        filing_id=payload.metadata.get("filingId"),
    )
    return ToolMemoryWriteResponse(stored=bool(stored))


__all__ = ["router"]
